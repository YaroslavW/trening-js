# 7 лучших шаблонов дизайна JavaScript, которые вы должны знать

 7 лучших шаблонов проектирования JavaScript, которые вы должны знать. Шаблоны проектирования в JavaScript - это многоразовые решения, применяемые для решения часто возникающих проблем при написании веб-приложений на JavaScript.

 ## Введение
 
Вполне уместно называть шаблоны проектирования JavaScript шаблонами для решения проблем, но это не совсем то, что эти шаблоны могут заменить разработчиков.

Шаблоны проектирования помогают объединить опыт многих разработчиков, чтобы оптимизировать структуру кода для решения проблем, которые мы ищем, и дают общий словарь, используемый для описания решений наших проблем, а не для описания синтаксиса и семантики нашего кода.

Шаблоны проектирования JavaScript помогают разработчикам писать организованный, красивый и хорошо структурированный код. Хотя шаблоны проектирования при использовании могут быть легко использованы повторно, они никогда не могут служить дополнением к разработчикам, а только поддерживают их, предотвращая незначительные проблемы, которые могут привести к серьезным проблемам при разработке веб-приложений, путем предоставления обобщенных решений, не привязанных к конкретным проблемам.

Они уменьшают общую кодовую базу за счет устранения ненужных повторов, что делает наш код более надежным, чем специальные, собственные решения.

В этой статье я исследую семь лучших и самых популярных шаблонов проектирования JavaScript, большинство из которых, конечно же, подпадут под три категории: создание шаблонов проектирования, структурных шаблонов проектирования и шаблонов поведенческого проектирования. Шаблон похож на следующее изображение; просто чтобы познакомить вас с контекстом.

**1. Шаблон проектирования конструктор.**
Это специальный метод, который используется для инициализации вновь созданных объектов после выделения памяти. Поскольку JavaScript обычно является объектно-ориентированным, он больше всего работает с объектами, поэтому я намерен углубиться в конструкторы объектов. Есть три способа создания новых объектов в JavaScript:

Ниже приведен один из способов создания шаблона проектирования конструктора.

```js
// This creates a new empty Object

var newObject = {};

// This creates a new empty Object

var newObject = Object.create(Object.prototype);

var newObject = newObject();
```

**Чтобы получить доступ к свойствам функции, вам необходимо инициализировать объект.**

```js
const object = new ConstructorObject();
```

При этом новое ключевое слово выше сообщает JavaScript, что объект `aconstructorObjects` должен действовать как конструктор. Наследование - это то, что этот шаблон проектирования не поддерживает. Узнать подробности
можно [здесь](https://addyosmani.com/resources/essentialjsdesignpatterns/book/#constructorpatternjavascript)


**## 2. Prototype Pattern**
Паттерн прототипа основан на наследовании прототипов, при котором объекты создаются, чтобы действовать как прототипы для других объектов. На самом деле прототипы действуют как проект для каждого созданного конструктора объекта.

_Пример_

```js
var myCat= {
name:"Ford Escort",
brake:function(){
console.log("Stop! I am applying brakes");
}
Panic : function (){
console.log ( "wait. how do you stop thuis thing?")
}
}
// use objec create to instansiate a new car
// используем объект create для создания экземпляра новой машины
var yourCar= object.create(myCar);
//You can now see that one is a prototype of the other
// Теперь вы можете видеть, что один является прототипом другого.
console.log (yourCar.name);]
```


**3. Module Design Pattern**
В шаблоне проектирования модуля есть улучшение по сравнению с шаблоном-прототипом. В шаблоне модуля задаются различные типы модификаторов (как частные, так и общедоступные). Вы можете создавать аналогичные функции или свойства без конфликтов. Существует возможность публичного переименования функций. Пугающей частью этого является невозможность переопределить созданные функции извне.

_Например_

```js
function AnimalContainter () {

const container = [];

function addAnimal (name) {
container.push(name);
}

function getAllAnimals() {
return container;
}

function removeAnimal(name) {
const index = container.indexOf(name);
if(index < 1) {
throw new Error('Animal not found in container');
}
container.splice(index, 1)
}

return {
add: addAnimal,
get: getAllAnimals,
remove: removeAnimal
}
}

const container = AnimalContainter();
container.add('Hen');
container.add('Goat');
container.add('Sheep');

console.log(container.get()) //Array(3) ["Hen", "Goat", "Sheep"]
container.remove('Sheep')
console.log(container.get()); //Array(2) ["Hen", "Goat"]
```

**4. Singleton Pattern**
