# Знаете ли вы ES6 - часть 3.

[Знаете ли вы ES6 - часть 1.](https://github.com/YaroslavW/trening-js/blob/master/Texts/ES6/es6-part1.md)

[Знаете ли вы ES6 - часть 2.](https://github.com/YaroslavW/trening-js/blob/master/Texts/ES6/es6-part2.md)

Содержание:

- IIFE Immediately Invoked Function Expression - Немедленно вызванное функциональное выражение.
- Closures - Замыкания.
- Synchronous vs Asynchronous - Синхронность -Асинхронность.
- Promises - Обещания (промисы)
- Async vs Await - Ожидания (асинк \ авейт)

## IIFE (Immediately Invoked Function Expression)

IIFE относится к выражению немедленного вызова функции. IIFE - это функция JavaScript, которая запускается сразу после ее определения. [MDN Web Docs](https://developer.mozilla.org/en-US/docs/Glossary/IIFE "mozilla.org")

IIFE отличается от традиционной функции, которую мы можем назвать несколько раз, но IIFE нет. IIFE используется только один раз. Поэтому мы не будем использовать его снова. Это означает, что переменные в функции не доступны, поэтому они неизменны.

Одним из преимуществ IIFE является создание локальной области, и это очень важно, если у меня много js-файлов, которые могут иметь одинаковые имена переменных. Таким образом, IIFE избегает переопределения и защищает область своих переменных.

Есть два способа вызвать функцию:

1. Во-первых, наш традиционный способ определить и вызвать функцию

```javascript
function printName() {
  let myName = "Yaroslav";
  console.log(myName);
  // Yaroslav
}

//Invoke
printName();
```

2. Во-вторых, используя IIFE. Мы заключаем нашу функцию в скобки, затем добавляем пару скобок в конце функции

(Наша функция) (Invoke - вызвать)

(Наша функция) ()

```javascript
(function printName() {
  let myName = "Yaroslav";
  console.log(myName);
  // Yaroslav
})();
```

На самом деле нам не нужно давать имя функции, потому что она вызывается только один раз. Так что IIFE обычно будет анонимной функцией

```javascript
(function() {
  let myName = "Yaroslav";
  console.log(myName);
  // Yaroslav
})();
```

## Closures - Замыкания

Замыкания - это когда функция запоминает свою лексическую область видимости, даже если функция выполняется вне лексической области видимости. Таким образом, замыкание - это когда функция использует переменную, определенную в другой функции или другой области видимости. Так что сделайте ссылку на эту переменную, чтобы обновить ее значение.

В примере у нас есть функция `printName`, которая имеет переменную. Затем у нас есть вложенная функция печати, которая использует эту переменную в этой области. Тогда у нас есть функция замыкания, которая вызывает функцию печати. Наконец, мы можем вызвать эту функцию в другой области.

Другими словами, мы можем выполнить функцию печати, которая использует переменную имени. Эта переменная не объявлена здесь в области действия функции замыкания. Но эта переменная находится в области действия функции `printName`.

По умолчанию логика неверна. Но на самом деле это замыкание и это работает. Поэтому, если мы изменим или обновим значение нашего имени переменной, замыкание обновит его.

```javascript
function printName() {
  var name = "Yaroslav";
  //name="Yaroslav Kolesnikov";
  function print() {
    console.log(name);
  }

  closure(print);
}

function closure(func) {
  func();
}

printName();
```

Другой пример, мы можем получить и обновить переменную x во внутренней функции

```javascript
function outer() {
  let x = 4;
  function inner() {
    let y = x;
    y = 16;
    console.log(x);
    console.log(x * 2);
    console.log(y);
  }

  closure(inner);
}

function closure(inn) {
  inn();
}

outer();
```

Это еще один способ создать предыдущую функцию замыкания. Здесь мы заменили внутреннюю функцию на анонимную функцию, которая возвращает несколько значений в массиве. Затем мы выполнили внешнюю функцию.

```javascript
function outer() {
  let x = 4;
  return function() {
    let y = x;
    y = 16;
    return [x, x * 2, y];
  };
}

//IIFE
console.log(outer()());

//let res = outer()
//console.log(res());
```

давайте посмотрим на другой пример, это простой счетчик, использующий замыкание. В любом случае, я рекомендую вам использовать `++n` и увидеть разницу.

```javascript
function counter(n) {
  return function() {
    return n++;
  };
}

let res = counter(1);
console.log(res());
console.log(res());
console.log(res());
console.log(res());
console.log(res());
```

давайте углубимся в более сложное. Что вы ожидаете выхода этого кода? СЧИТАТЬ!!

```javascript
for (var i = 0; i < 10; i++) {
  setTimeout(function() {
    console.log(i);
  }, 100);
}
```

После размышления. Выходное значение является последним значением нашего счетчика `i`. Которое равно - `10`.

Потому что `i` переменная, определенная в глобальной области видимости. Так что это произошло из-за замыкания. Опять же, Clousure - замыкание использует последнее значение нашей переменной, которое определено в другой области видимости.

Я думаю, вы хотите знать, как решить эту проблему? Хорошо, есть более одного решения. Один из них - использовать `let` для создания счетчика `i`, потому что `let` - это локальная область, а не глобальная.

```javascript
for (let i = 0; i < 10; i++) {
  setTimeout(function() {
    console.log(i);
  }, 100);
}
```

Мы можем решить это, используя функцию IIFE, которая выполняется немедленно. Так что замыкание фиксирует setTimeout.

```javascript
function closure(index) {
  setTimeout(function() {
    console.log(index);
  }, 100);
}

for (var i = 0; i < 10; i++) {
  closure(i);
}
```

Более подробно это, я разбирал в первой части - [Знаете ли вы ES6 - часть 1.](https://github.com/YaroslavW/trening-js/blob/master/Texts/ES6/es6-part1.md)

## Synchronous vs Asynchronous
