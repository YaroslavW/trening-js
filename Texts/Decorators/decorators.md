# Декораторы.

В этой статье описывается новое предложение, которое будет представлено TC39 на собрании в сентябре 2020 года.

## Введение

Декораторы - это предложение по расширению классов JavaScript, которое широко используется разработчиками в среде транспиляторов, проявляющих большой интерес к стандартизации. TC39 работает над предложениями декораторов более пяти лет. Этот документ описывает новое предложение для декораторов, основанное на элементах из всех прошлых предложений.

**Декораторы** `@decorator` - это функции, вызываемые в элементах класса или других формах синтаксиса JavaScript во время определения, потенциально _оборачивающие_ или _заменяющие_ их новым значением, возвращаемым декоратором.

Декорированное поле класса рассматривается как упаковка пары `геттер / сеттер` для доступа к этому хранилищу. Декорированное хранилище полезно для наблюдения / отслеживания, что было проблемой для оригинальных устаревших / экспериментальных декораторов в сочетании с семантикой [[Define]] для полей классов. Эта семантика основана на предложении Мишеля Вестстрата о [«декораторах захвата»](https://github.com/tc39/proposal-decorators/issues/299).

Декораторы также могут аннотировать элемент класса метаданными. Это простые, неограниченные свойства объекта, которые собираются от всех добавляющих их декораторов и становятся доступными в виде набора вложенных объектов в свойстве [Symbol.metadata]. 

Благодаря тому, что декораторы всегда просто оборачивают то, что они украшают, вместо того, чтобы выполнять другие преобразования, это предложение направлено на выполнение следующих требований:

* Класс "shape" виден без выполнения кода, что делает декораторы более оптимизированными для движков. 
* Реализации могут работать полностью для отдельных файлов, без необходимости знания кросс-файлов. 
* Не добавляется новое пространство имен или тип второсортного значения - декораторы - это функции.


## Примеры
Несколько примеров того, как реализовать и использовать декораторы в этом предложении:

### `@logged`
Декоратор `@logged` записывает консольное сообщение при запуске и завершении метода. Многие другие популярные декораторы также захотят обернуть функцию, например, `@deprecated`, `@debounce`, `@memoize` и т. д.

Использование:

```js
import { logged } from "./logged.mjs";

class C {
  @logged
  m(arg) {
    this.#x = arg;
  }

  @logged
  set #x(value) { }
}

new C().m(1);
// starting m with arguments 1
// starting set #x with arguments 1
// ending set #x
// ending m
```
