# Декораторы.

В этой статье описывается новое предложение, которое будет представлено TC39 на собрании в сентябре 2020 года.

## Введение

Декораторы - это предложение по расширению классов JavaScript, которое широко используется разработчиками в среде транспиляторов, проявляющих большой интерес к стандартизации. TC39 работает над предложениями декораторов более пяти лет. Этот документ описывает новое предложение для декораторов, основанное на элементах из всех прошлых предложений.

**Декораторы** `@decorator` - это функции, вызываемые в элементах класса или других формах синтаксиса JavaScript во время определения, потенциально _оборачивающие_ или _заменяющие_ их новым значением, возвращаемым декоратором.

Декорированное поле класса рассматривается как упаковка пары `геттер / сеттер` для доступа к этому хранилищу. Декорированное хранилище полезно для наблюдения / отслеживания, что было проблемой для оригинальных устаревших / экспериментальных декораторов в сочетании с семантикой [[Define]] для полей классов. Эта семантика основана на предложении Мишеля Вестстрата о [«декораторах захвата»](https://github.com/tc39/proposal-decorators/issues/299).

Декораторы также могут аннотировать элемент класса метаданными. Это простые, неограниченные свойства объекта, которые собираются от всех добавляющих их декораторов и становятся доступными в виде набора вложенных объектов в свойстве [Symbol.metadata].

Благодаря тому, что декораторы всегда просто оборачивают то, что они украшают, вместо того, чтобы выполнять другие преобразования, это предложение направлено на выполнение следующих требований:

- Класс "shape" виден без выполнения кода, что делает декораторы более оптимизированными для движков.
- Реализации могут работать полностью для отдельных файлов, без необходимости знания кросс-файлов.
- Не добавляется новое пространство имен или тип второсортного значения - декораторы - это функции.

## Примеры

Несколько примеров того, как реализовать и использовать декораторы в этом предложении:

### `@logged`

Декоратор `@logged` записывает консольное сообщение при запуске и завершении метода. Многие другие популярные декораторы также захотят обернуть функцию, например, `@deprecated`, `@debounce`, `@memoize` и т. д.

Использование:

```js
import { logged } from "./logged.mjs";

class C {
  @logged
  m(arg) {
    this.#x = arg;
  }

  @logged
  set #x(value) {}
}

new C().m(1);
// starting m with arguments 1
// starting set #x with arguments 1
// ending set #x
// ending m
```

`@logged` можно реализовать в JavaScript как декоратор. Декораторы - это функции, которые вызываются с аргументом, содержащим то, что декорируется. Например:

- Декорируемый метод вызывается декорируемым методом.
- Декорированный геттер вызывается с декорированной функцией геттера
- Декорированный сеттер вызывается с декорированной функцией сеттера

(Декораторы вызываются со вторым параметром, дающим больше контекста, но нам не нужны эти детали для декоратора `@logged`.)

Возвращаемое значение декоратора - это новое значение, которое заменяет то, что он упаковывает. Для методов, геттер и сеттеров (getter and setter) возвращаемое значение - это другая функция, заменяющая этот метод, геттер или сеттер (getter or setter).

```js
// logged.mjs

export function logged(f) {
  const name = f.name;
  function wrapped(...args) {
    console.log(`starting ${name} with arguments ${args.join(", ")}`);
    const ret = f.call(this, ...args);
    console.log(`ending ${name}`);
    return ret;
  }
  wrapped.name = name;
  return wrapped;
}
```

Этот пример примерно «десахарирует» ("desugars") к следующему (т.е. может быть передан как таковой):

```js
let x_setter;

class C {
  m(arg) {
    this.#x = arg;
  }

  static #x_setter(value) { }
  static { x_setter = C.#x_setter; }
  set #x(value) { return x_setter.call(this, value); }
}

C.prototype.m = logged(C.prototype.m, { kind: "method", name: "method", isStatic: false });
x_setter = logged(x_setter, {kind: "setter", isStatic: false});
```

Обратите внимание, что геттеры и сеттеры оформляются отдельно. Аксессоры не «объединяются», как в предыдущих предложениях декораторов (если они не созданы для поля; см. Ниже).

Этот "desugars" относится к предложению статического блока класса - [class static block proposal](), которое предоставляет статическую конструкцию `static { }` для использования внутри тела класса, работающего в лексической области видимости класса. Также возможно "desugars" с точки зрения одноразовых статических частных полей, но это беспорядочно и запутанно. Однако предложение декораторов не зависит от статических блоков класса; это просто пояснительный прием.

### `@defineElement`
Пользовательские элементы HTML - [HTML Custom Elements](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements) позволяют определить собственный элемент HTML. Элементы регистрируются с помощью `customElements.define`. Используя декораторы, регистрация может происходить заранее:

```js
import { defineElement } from "./defineElement.mjs";

@defineElement('my-class')
class MyClass extends HTMLElement { }
```
Классы можно декорировать так же, как методы и средства доступа. Класс отображается в опции значения - `value`.

```js
// defineElement.mjs
export function defineElement(name, options) {
  return klass => { customElements.define(name, klass, options); return klass; }
}
```

