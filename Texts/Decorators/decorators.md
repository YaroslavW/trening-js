# Декораторы.

В этой статье описывается новое предложение, которое будет представлено TC39 на собрании в сентябре 2020 года.

## Введение

Декораторы - это предложение по расширению классов JavaScript, которое широко используется разработчиками в среде транспиляторов, проявляющих большой интерес к стандартизации. TC39 работает над предложениями декораторов более пяти лет. Этот документ описывает новое предложение для декораторов, основанное на элементах из всех прошлых предложений.

**Декораторы** `@decorator` - это функции, вызываемые в элементах класса или других формах синтаксиса JavaScript во время определения, потенциально _оборачивающие_ или _заменяющие_ их новым значением, возвращаемым декоратором.

Декорированное поле класса рассматривается как упаковка пары `геттер / сеттер` для доступа к этому хранилищу. Декорированное хранилище полезно для наблюдения / отслеживания, что было проблемой для оригинальных устаревших / экспериментальных декораторов в сочетании с семантикой [[Define]] для полей классов. Эта семантика основана на предложении Мишеля Вестстрата о [«декораторах захвата»](https://github.com/tc39/proposal-decorators/issues/299).

Декораторы также могут аннотировать элемент класса метаданными. Это простые, неограниченные свойства объекта, которые собираются от всех добавляющих их декораторов и становятся доступными в виде набора вложенных объектов в свойстве [Symbol.metadata].

Благодаря тому, что декораторы всегда просто оборачивают то, что они украшают, вместо того, чтобы выполнять другие преобразования, это предложение направлено на выполнение следующих требований:

- Класс "shape" виден без выполнения кода, что делает декораторы более оптимизированными для движков.
- Реализации могут работать полностью для отдельных файлов, без необходимости знания кросс-файлов.
- Не добавляется новое пространство имен или тип второсортного значения - декораторы - это функции.

## Примеры

Несколько примеров того, как реализовать и использовать декораторы в этом предложении:

### `@logged`

Декоратор `@logged` записывает консольное сообщение при запуске и завершении метода. Многие другие популярные декораторы также захотят обернуть функцию, например, `@deprecated`, `@debounce`, `@memoize` и т. д.

Использование:

```js
import { logged } from "./logged.mjs";

class C {
  @logged
  m(arg) {
    this.#x = arg;
  }

  @logged
  set #x(value) {}
}

new C().m(1);
// starting m with arguments 1
// starting set #x with arguments 1
// ending set #x
// ending m
```

`@logged` можно реализовать в JavaScript как декоратор. Декораторы - это функции, которые вызываются с аргументом, содержащим то, что декорируется. Например:

- Декорируемый метод вызывается декорируемым методом.
- Декорированный геттер вызывается с декорированной функцией геттера
- Декорированный сеттер вызывается с декорированной функцией сеттера

(Декораторы вызываются со вторым параметром, дающим больше контекста, но нам не нужны эти детали для декоратора `@logged`.)

Возвращаемое значение декоратора - это новое значение, которое заменяет то, что он упаковывает. Для методов, геттер и сеттеров (getter and setter) возвращаемое значение - это другая функция, заменяющая этот метод, геттер или сеттер (getter or setter).

```js
// logged.mjs

export function logged(f) {
  const name = f.name;
  function wrapped(...args) {
    console.log(`starting ${name} with arguments ${args.join(", ")}`);
    const ret = f.call(this, ...args);
    console.log(`ending ${name}`);
    return ret;
  }
  wrapped.name = name;
  return wrapped;
}
```

Этот пример примерно «десахарирует» ("desugars") к следующему (т.е. может быть передан как таковой):

```js
let x_setter;

class C {
  m(arg) {
    this.#x = arg;
  }

  static #x_setter(value) { }
  static { x_setter = C.#x_setter; }
  set #x(value) { return x_setter.call(this, value); }
}

C.prototype.m = logged(C.prototype.m, { kind: "method", name: "method", isStatic: false });
x_setter = logged(x_setter, {kind: "setter", isStatic: false});
```

Обратите внимание, что геттеры и сеттеры оформляются отдельно. Аксессоры не «объединяются», как в предыдущих предложениях декораторов (если они не созданы для поля; см. Ниже).

Этот "desugars" относится к предложению статического блока класса - [class static block proposal](), которое предоставляет статическую конструкцию `static { }` для использования внутри тела класса, работающего в лексической области видимости класса. Также возможно "desugars" с точки зрения одноразовых статических частных полей, но это беспорядочно и запутанно. Однако предложение декораторов не зависит от статических блоков класса; это просто пояснительный прием.

### `@defineElement`

Пользовательские элементы HTML - [HTML Custom Elements](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements) позволяют определить собственный элемент HTML. Элементы регистрируются с помощью `customElements.define`. Используя декораторы, регистрация может происходить заранее:

```js
import { defineElement } from "./defineElement.mjs";

@defineElement("my-class")
class MyClass extends HTMLElement {}
```

Классы можно декорировать так же, как методы и средства доступа. Класс отображается в опции значения - `value`.

```js
// defineElement.mjs
export function defineElement(name, options) {
  return (klass) => {
    customElements.define(name, klass, options);
    return klass;
  };
}
```

Декоратор принимает аргументы на месте своего использования, поэтому он реализован как функция, возвращающая другую функцию. Вы можете думать об этом как о «фабрике декораторов»: после применения аргументов он дает вам еще один декоратор.

Этот декоратор можно также "десахаризировать" (desugared):

```js
class MyClass extends HTMLElement {}
MyClass = defineElement("my-class")(MyClass, { kind: "class" });
```

#### Декораторы, добавляющие метаданные

Декораторы могут добавлять метаданные об элементах класса, добавляя свойство `metadata` объекту контекста, который им передается. Все объекты метаданных объединяются в `Object.assign` и помещаются в свойство, доступное из [`Symbol.metadata`] в классе. Например:

```js
@annotate({ x: "y" })
@annotate({ v: "w" })
class C {
  @annotate({ a: "b" }) method() {}
  @annotate({ c: "d" }) field;
}

C[Symbol.metadata].class.x; // "y"
C[Symbol.metadata].class.v; // "w"
C[Symbol.metadata].prototype.methods.method.a; // "a"
C[Symbol.metadata].instance.fields.field.c; // "d"
```

**ПРИМЕЧАНИЕ**. Точный формат объекта аннотаций не очень хорошо продуман и требует дополнительных уточнений. Главное, что я хотел бы здесь проиллюстрировать, это то, что это просто объект без какой-либо специальной библиотеки поддержки для чтения или записи, и он автоматически создается системой.

Этот декоратор `@annotate` может быть реализован следующим образом:

```js
function annotate(metadata) {
  return (_, context) => {
    context.metadata = metadata;
    return _;
  };
}
```

Каждый раз, когда вызывается декоратор, ему передается новый объект контекста, и после возвращения каждого декоратора считывается свойство метаданных объекта -`metadata` контекста, и если оно не определено, оно включается в [Symbol.metadata] для этого элемента класса.

Обратите внимание: поскольку метаданные хранятся в классе, а не в методе, метаданные не видны более ранним декораторам. Метаданные классов добавляются в конструктор после запуска всех декораторов классов, чтобы они не были потеряны при последующей упаковке.

### `@tracked`

Декоратор `@tracked` наблюдает за полем и запускает метод `render ()` при вызове установщика. Этот или подобные ему шаблоны распространены во фреймворках, чтобы избежать разброса по всему приложению лишней 'бухгалтерии', требующей повторного рендеринга.

Декорированные поля имеют семантику пар геттер / сеттер вокруг базовой части частного хранилища - ( private storage). Декораторы могут обернуть эти функции getter/setter. `@tracked` может обернуть эту пару геттер / сеттер для реализации поведения повторного рендеринга.

```js
import { tracked } from "./tracked.mjs";

class Element {
  @tracked counter = 0;

  increment() {
    this.counter++;
  }

  render() {
    console.log(counter);
  }
}

const e = new Element();
e.increment(); // logs 1
e.increment(); // logs 2
```
