# Декораторы.

В этой статье описывается новое предложение, которое будет представлено TC39 на собрании в сентябре 2020 года.

## Введение

Декораторы - это предложение по расширению классов JavaScript, которое широко используется разработчиками в среде транспиляторов, проявляющих большой интерес к стандартизации. TC39 работает над предложениями декораторов более пяти лет. Этот документ описывает новое предложение для декораторов, основанное на элементах из всех прошлых предложений.

**Декораторы** `@decorator` - это функции, вызываемые в элементах класса или других формах синтаксиса JavaScript во время определения, потенциально _оборачивающие_ или _заменяющие_ их новым значением, возвращаемым декоратором.

Декорированное поле класса рассматривается как упаковка пары `геттер / сеттер` для доступа к этому хранилищу. Декорированное хранилище полезно для наблюдения / отслеживания, что было проблемой для оригинальных устаревших / экспериментальных декораторов в сочетании с семантикой [[Define]] для полей классов. Эта семантика основана на предложении Мишеля Вестстрата о [«декораторах захвата»](https://github.com/tc39/proposal-decorators/issues/299).

Декораторы также могут аннотировать элемент класса метаданными. Это простые, неограниченные свойства объекта, которые собираются от всех добавляющих их декораторов и становятся доступными в виде набора вложенных объектов в свойстве [Symbol.metadata].

Благодаря тому, что декораторы всегда просто оборачивают то, что они украшают, вместо того, чтобы выполнять другие преобразования, это предложение направлено на выполнение следующих требований:

- Класс "shape" виден без выполнения кода, что делает декораторы более оптимизированными для движков.
- Реализации могут работать полностью для отдельных файлов, без необходимости знания кросс-файлов.
- Не добавляется новое пространство имен или тип второсортного значения - декораторы - это функции.

## Примеры

Несколько примеров того, как реализовать и использовать декораторы в этом предложении:

### `@logged`

Декоратор `@logged` записывает консольное сообщение при запуске и завершении метода. Многие другие популярные декораторы также захотят обернуть функцию, например, `@deprecated`, `@debounce`, `@memoize` и т. д.

Использование:

```js
import { logged } from "./logged.mjs";

class C {
  @logged
  m(arg) {
    this.#x = arg;
  }

  @logged
  set #x(value) {}
}

new C().m(1);
// starting m with arguments 1
// starting set #x with arguments 1
// ending set #x
// ending m
```

`@logged` можно реализовать в JavaScript как декоратор. Декораторы - это функции, которые вызываются с аргументом, содержащим то, что декорируется. Например:

- Декорируемый метод вызывается декорируемым методом.
- Декорированный геттер вызывается с декорированной функцией геттера
- Декорированный сеттер вызывается с декорированной функцией сеттера

(Декораторы вызываются со вторым параметром, дающим больше контекста, но нам не нужны эти детали для декоратора `@logged`.)

Возвращаемое значение декоратора - это новое значение, которое заменяет то, что он упаковывает. Для методов, геттер и сеттеров (getter and setter) возвращаемое значение - это другая функция, заменяющая этот метод, геттер или сеттер (getter or setter).

```js
// logged.mjs

export function logged(f) {
  const name = f.name;
  function wrapped(...args) {
    console.log(`starting ${name} with arguments ${args.join(", ")}`);
    const ret = f.call(this, ...args);
    console.log(`ending ${name}`);
    return ret;
  }
  wrapped.name = name;
  return wrapped;
}
```

Этот пример примерно «десахарирует» ("desugars") к следующему (т.е. может быть передан как таковой):

```js
let x_setter;

class C {
  m(arg) {
    this.#x = arg;
  }

  static #x_setter(value) { }
  static { x_setter = C.#x_setter; }
  set #x(value) { return x_setter.call(this, value); }
}

C.prototype.m = logged(C.prototype.m, { kind: "method", name: "method", isStatic: false });
x_setter = logged(x_setter, {kind: "setter", isStatic: false});
```

Обратите внимание, что геттеры и сеттеры оформляются отдельно. Аксессоры не «объединяются», как в предыдущих предложениях декораторов (если они не созданы для поля; см. Ниже).

Этот "desugars" относится к предложению статического блока класса - [class static block proposal](), которое предоставляет статическую конструкцию `static { }` для использования внутри тела класса, работающего в лексической области видимости класса. Также возможно "desugars" с точки зрения одноразовых статических частных полей, но это беспорядочно и запутанно. Однако предложение декораторов не зависит от статических блоков класса; это просто пояснительный прием.

### `@defineElement`

Пользовательские элементы HTML - [HTML Custom Elements](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements) позволяют определить собственный элемент HTML. Элементы регистрируются с помощью `customElements.define`. Используя декораторы, регистрация может происходить заранее:

```js
import { defineElement } from "./defineElement.mjs";

@defineElement("my-class")
class MyClass extends HTMLElement {}
```

Классы можно декорировать так же, как методы и средства доступа. Класс отображается в опции значения - `value`.

```js
// defineElement.mjs
export function defineElement(name, options) {
  return (klass) => {
    customElements.define(name, klass, options);
    return klass;
  };
}
```

Декоратор принимает аргументы на месте своего использования, поэтому он реализован как функция, возвращающая другую функцию. Вы можете думать об этом как о «фабрике декораторов»: после применения аргументов он дает вам еще один декоратор.

Этот декоратор можно также "десахаризировать" (desugared):

```js
class MyClass extends HTMLElement {}
MyClass = defineElement("my-class")(MyClass, { kind: "class" });
```

#### Декораторы, добавляющие метаданные

Декораторы могут добавлять метаданные об элементах класса, добавляя свойство `metadata` объекту контекста, который им передается. Все объекты метаданных объединяются в `Object.assign` и помещаются в свойство, доступное из [`Symbol.metadata`] в классе. Например:

```js
@annotate({ x: "y" })
@annotate({ v: "w" })
class C {
  @annotate({ a: "b" }) method() {}
  @annotate({ c: "d" }) field;
}

C[Symbol.metadata].class.x; // "y"
C[Symbol.metadata].class.v; // "w"
C[Symbol.metadata].prototype.methods.method.a; // "a"
C[Symbol.metadata].instance.fields.field.c; // "d"
```

**ПРИМЕЧАНИЕ**. Точный формат объекта аннотаций не очень хорошо продуман и требует дополнительных уточнений. Главное, что я хотел бы здесь проиллюстрировать, это то, что это просто объект без какой-либо специальной библиотеки поддержки для чтения или записи, и он автоматически создается системой.

Этот декоратор `@annotate` может быть реализован следующим образом:

```js
function annotate(metadata) {
  return (_, context) => {
    context.metadata = metadata;
    return _;
  };
}
```

Каждый раз, когда вызывается декоратор, ему передается новый объект контекста, и после возвращения каждого декоратора считывается свойство метаданных объекта -`metadata` контекста, и если оно не определено, оно включается в [Symbol.metadata] для этого элемента класса.

Обратите внимание: поскольку метаданные хранятся в классе, а не в методе, метаданные не видны более ранним декораторам. Метаданные классов добавляются в конструктор после запуска всех декораторов классов, чтобы они не были потеряны при последующей упаковке.

### `@tracked`

Декоратор `@tracked` наблюдает за полем и запускает метод `render ()` при вызове установщика. Этот или подобные ему шаблоны распространены во фреймворках, чтобы избежать разброса по всему приложению лишней 'бухгалтерии', требующей повторного рендеринга.

Декорированные поля имеют семантику пар геттер / сеттер вокруг базовой части частного хранилища - ( private storage). Декораторы могут обернуть эти функции getter/setter. `@tracked` может обернуть эту пару геттер / сеттер для реализации поведения повторного рендеринга.

```js
import { tracked } from "./tracked.mjs";

class Element {
  @tracked counter = 0;

  increment() {
    this.counter++;
  }

  render() {
    console.log(counter);
  }
}

const e = new Element();
e.increment(); // logs 1
e.increment(); // logs 2
```

Когда поля декорированы, «обернутое» значение представляет собой объект с двумя свойствами: функции `get` и `set`, которые управляют базовым хранилищем (storage). Они созданы для использования `.call ()` с экземпляром класса в качестве получателя. Затем декоратор может вернуть новый объект той же формы. (Если один из обратных вызовов отсутствует, он остается на месте необернутым - (unwrapped).)

```js
// tracked.mjs

export function tracked({ get, set }) {
  return {
    get,
    set(value) {
      if (get.call(this) !== value) {
        set.call(this, value);
        this.render();
      }
    },
  };
}
```

Этот пример показывает грубую "десахаризацию" (desugared) следующим образом:

```js
let initialize, get, set;

class Element {
  #counter = initialize(0);
  get counter() { return this.#counter; }
  set counter(v) { this.#counter = v; }

  increment() { this.counter++; }

  render() { console.log(counter); }
}

{ get, set } = Object.getOwnPropertyDescriptor(Element.prototype, "counter");
{ get, set, initialize } = tracked({get, set}, { kind: "field", name: "counter", isStatic: false })
Object.defineProperty(Element.prototype, "counter", {get, set});
```

#### Ограниченный доступ к приватным полям и методам

Иногда определенному коду вне класса может потребоваться доступ к закрытым полям и методам. Например, два класса могут «взаимодействовать», или тестовый код в другом файле должен попасть внутрь класса.

Декораторы могут сделать это возможным, предоставив кому-либо доступ к закрытому полю или методу. Это может быть инкапсулировано в «закрытый ключ» ("private key") - объект, содержащий эти ссылки, который будет использоваться только для тех, кому это необходимо.

```js
import { PrivateKey } from "./private-key.mjs";

let key = new PrivateKey();

export class Box {
  @key.show #contents;
}

export function setBox(box, contents) {
  return key.set(box, contents);
}

export function getBox(box) {
  return key.get(box);
}
```

Обратите внимание, что это своего рода взлом, и его можно было бы улучшить с помощью таких конструкций, как ссылки на частные имена с помощью [`private.name`](https://gist.github.com/littledan/ab73ff08f98f33088a0072ad202445b1) и более широкой области частных имен с помощью [`private / with`](https://gist.github.com/littledan/5451d6426a8ed65c0f3c2822c51314d1). Но это показывает, что это предложение декоратора «естественно» раскрывает существующие вещи полезным способом.

```js
// private-key.mjs
export class PrivateKey {
  #get;
  #set;

  show({ get, set }) {
    assert(this.#get === undefined && this.#set === undefined);
    this.#get = get;
    this.#set = set;
    return { get, set };
  }
  get(obj) {
    return this.#get(obj);
  }
  set(obj, value) {
    return this.#set(obj, value);
  }
}
```

Этот пример можно грубо "обессахаривать" (desugared) следующим образом:

```js
let initialize, get, set;
export class Box {
  #_contents = initialize(undefined);
  get #contents() { return get.call(this); }
  set #contents(v) { set.call(this, v); }

  static {
    get = function() { return this.#_contents; },
    set = function(v) { this.#_contents = v; }
  }
}
({get, set, initialize} = key.show({get, set}, {kind: "field", isStatic: false}));
```

### `@deprecated`

Декоратор `@deprecated` выводит предупреждения при использовании устаревшего поля, метода или средства доступа. В качестве примера использования:

```js
import { deprecated } from "./deprecated.mjs";

export class MyClass {
  @deprecated field;

  @deprecated method() {}

  otherMethod() {}
}
```

Чтобы `deprecated` - нерекомендуемые элементы могли работать с различными типами элементов класса, поле `kind` объекта контекста позволяет декораторам видеть, какой тип синтаксической конструкции они не рекомендуют. Этот метод также позволяет выдавать ошибку, когда декоратор используется в контексте, где он не может применяться - например, весь класс не может быть помечен как устаревший, поскольку нет способа перехватить его доступ.

```js
// deprecated.mjs

function wrapDeprecated(fn) {
  let name = fn.name;
  function method(...args) {
    console.warn(`call to deprecated code ${name}`);
    return fn.call(this, ...args);
  }
  method.name = name;
  return method;
}

export function deprecated(element, { kind }) {
  switch (kind) {
    case "method":
    case "getter":
    case "setter":
      return wrapDecorated(element);
    case "field": {
      let { get, set } = element;
      return { get: wrapDeprecated(get), set: wrapDeprecated(set) };
    }
    default:
      // includes 'class'
      throw new Error(`Unsupported @deprecated target ${kind}`);
  }
}
```

Обессахаривание (desugaring) здесь аналогично приведенным выше примерам, которые показывают использование `kind`.

## Методы деораторов, требующие инициализации.

Некоторые методы декораторов основаны на выполнении кода при создании экземпляра класса. Например:

- Декоратор `@on('event')` для методов в классах, расширяющих HTMLElement, который регистрирует этот метод как прослушиватель событий в конструкторе.
- Декоратор `@bound`, который выполняет эквивалент `this.method = this.method.bind (this)` в конструкторе. Эта идиома отвечает цели Джордана Харбанда - быть более дружелюбной к monkey-patching, чем популярная идиома использования стрелочной функции в инициализаторе поля.

Мы рассматриваем несколько возможных вариантов того, как использовать этот тип идиомы.

### Вариант A. Конструкторы Mixin, обращающиеся к метаданным.

Эти декораторы могут быть созданы с помощью комбинации метаданных и миксина, который выполняет действия инициализации в своем конструкторе.

#### `@on` with a mixin

```js
class MyElement extends WithActions(HTMLElement) {
  @on("click") clickHandler() {}
}
```

Этот декоратор можно определить следующим образом:

```js
const handler = Symbol("handler");
function on(eventName)
  return (method, context) => {
    context.metadata = {[handler]: eventName};
    return method;
  }
}

class MetadataLookupCache {
  #map = new WeakMap();
  #name;
  constructor(name) { this.#name = name; }
  get(newTarget) {
    let data = this.#map.get(newTarget);
    if (data === undefined) {
      data = [];
      let klass = newTarget;
      while (klass !== null && !(this.#name in klass)) {
        for (const [name, {[this.#name]: eventName}]
             of Object.entries(klass[Symbol.metadata].instance.methods)) {
          if (eventName !== undefined) {
            data.push({name, eventName});
          }
        }
        klass = klass.__proto__;
      }
      this.#map.set(newTarget, data)
    }
    return data;
  }
}

let handlersMap = new MetadataLookupCache(handler);

function WithActions(superclass) {
  return class C extends superclass {
    constructor(...args) {
      super(...args);
      let handlers = handlersMap.get(new.target, C);
      for (const {name, eventName} of handlers) {
        this.addEventListener(eventName, this[name].bind(this));
      }
    }
  }
}
```

#### `@bound` with a mixin.

`@bound` может использоваться с суперклассом mixin следующим образом:

```js
class C extends WithBoundMethod(Object) {
  #x = 1;
  @bound method() {
    return this.#x;
  }
}

let c = new C();
let m = c.method;
m(); // 1, not TypeError
```

Этот декоратор можно определить как:

```js
const boundName = Symbol("boundName");
function bound(method, context) {
  context.metadata = { [boundName]: true };
  return method;
}
let boundMap = new MetadataLookupCache(boundName);

function WithBoundMethods(superclass) {
  return class C extends superclass {
    constructor(...args) {
      super(...args);
      let names = boundMap.get(new.target, C);
      for (const { name } of names) {
        this[name] = this[name].bind(this);
      }
    }
  };
}
```

Обратите внимание на общее использование `MetadataLookupCache` в обоих примерах; это или последующее предложение следует рассмотреть возможность добавления стандартной библиотеки для обработки метаданных для этой цели.

### Вариант Б. Контекстное ключевое слово `init` для методов.

Если требовать суперкласс / миксин для случаев, требующих действия инициализации, неприемлемо, ключевое слово `init` в объявлении метода изменяет метод на «метод инициализации». Это ключевое слово позволяет декораторам добавлять действия инициализации, запускаемые при выполнении конструктора.

#### `@on` with `init`

Использование:

```js
class MyElement extends HTMLElement {
  @on('click') init clickHandler() { }
}
```

«Метод инициализации» (метод, объявленный с помощью `init`) вызывается аналогично декоратору метода, но ожидается, что он вернет пару {метод, инициализация} - `{method, initialize}`, где инициализация вызывается с этим значением, являющимся новым экземпляром, без аргументов и ничего не вернув.

```js
function on(eventName) {
  return (method, context) => {
    assert(context.kind === "init-method");
    return {
      method,
      initialize() {
        this.addEventListener(eventName, method);
      },
    };
  };
}
```

'Обесахаривание' (desugared) определения класса будет примерно таким:

```js
let initialize;
class MyElement extends HTMLElement {
  clickHandler() { }
  constructor(...args) {
    super(...args);
    initialize.call(this);
  }
}
{method: MyElement.prototype.clickHandler, initialize} =
  on('click')(MyElement.prototype.clickHandler,
            {kind: "init-method", isStatic: false, name: "clickHandler"});
```

#### `@bound` with `init`

Ключевое слово `init` для методов также можно использовать для создания декоратора `@bound`, который используется следующим образом:

```js
class C {
  #x = 1;
  @bound init method() { return this.#x; }
}

let c = new C;
let m = c.method;
m();  // 1, not TypeError
```

Декоратор `@bound` может быть реализован следующим образом:

```js
function bound(method, { kind, name }) {
  assert(kind === "init-method");
  return {
    method,
    initialize() {
      this[name] = this[name].bind(this);
    },
  };
}
```

### Возможные расширения.

О декораторах дальнейших построек можно узнать на [EXTENSIONS.md](https://github.com/tc39/proposal-decorators/blob/simplified/EXTENSIONS.md).

## Синтаксис.

Это предложение декораторов использует синтаксис предыдущего предложения декораторов этапа 2. Это означает, что:

- Выражения-декораторы ограничены цепочкой переменных, доступ к свойствам с `.` но не `[]`, а `call()`. Чтобы использовать произвольное выражение в качестве декоратора, `@(expression)` - это escape-штрих.

- Выражения классов (Class expressions) могут быть декорированны, а не только объявления классов (class declarations).

- Декораторы классов идут после экспорта `export` и по умолчанию - `default`.

Не существует специального синтаксиса для определения декораторов; любая функция может быть применена как декоратор.

## Подробная семантика.

Три этапа оценки декоратора:

1. Выражения-декораторы (то, что стоит после `@`) _оцениваются_ вкраплениями с именами вычисленных свойств.
2. Декораторы _вызываются_ (как функции) во время определения класса после оценки методов, но до объединения конструктора и прототипа.
3. Декораторы _применяются_ (изменяя конструктор и прототип) сразу после того, как все они были вызваны.

Семантика здесь обычно соответствует консенсусу, достигнутому на встрече TC39 в мае 2016 года в Мюнхене.

### 1. Оценка декораторов

Декораторы оцениваются как выражения, чередующиеся в порядке их оценки с именами вычисленных свойств. Это идет слева направо, сверху вниз. Результат декораторов сохраняется в эквиваленте локальных переменных, которые впоследствии будут вызваны после того, как определение класса первоначально завершит выполнение.

### 2. Вызов декораторов

#### Оборачиваемый элемент: первый параметр

Первый параметр того, что оборачивает декоратор, зависит от того, что декорируется:

- В методе, методе инициализации, декораторе получателя или установщика: соответствующий объект функции
- В декораторе класса: класс
- В поле: объект с двумя свойствами
  - `get`: функция, которая не принимает аргументов, ожидается, что она будет вызвана с получателем (receiver), который - соответствующий объект, возвращающий базовое значение.
  - `set`: функция, которая принимает один аргумент (новое значение), ожидается, что она будет вызываться с получателем (receiver), который является устанавливаемым объектом, и ожидается, что она вернет `undefined`.

#### Объект контекста: второй параметр

Объект контекста - объект, переданный в качестве второго аргумента декоратору, - содержит следующие свойства:

- `kind`: Один из
  - `"class"`
  - `"method"`
  - `"init-method"`
  - `"getter"`
  - `"setter"`
  - `"field"`
- `name`:
  - Открытое поле или метод: `name` - это ключ свойства String или Symbol.
  - Частное (приватное) поле или метод: отсутствует (может быть представлено как некоторое представление частного имени в последующем предложении)
  - Класс: отсутствует - Class: missing
- `isStatic`:
  - Статическое поле (Static field ) или метод: `true`
  - Поле (Instance field) или метод экземпляра: `false`
  - Класс: отсутствует - Class: missing

«Цель» (конструктор или прототип) не передается в декораторы полей или методов, так как она еще не была построена при запуске декоратора.

#### Возвращаемое значение

Возвращаемое значение интерпретируется в зависимости от типа декоратора. Ожидается следующее возвращаемое значение:

- `Class`-Класс: новый класс
- Метод, геттер или сеттер: новая функция
- `field` - поле: объект с тремя свойствами (каждое по отдельности необязательно):
  - `get`: Функция той же формы, что и свойство `get` первого аргумента
  - `set`: То же, для `set`
  - `initialize` : A вызывается с теми же аргументами, что и `set`, который возвращает значение, которое используется для инициализирующего `set` переменной. Это вызывается при первоначальной настройке базового хранилища на основе инициализатора поля или определения метода. Этот метод не должен вызывать заданный ввод, так как это вызовет ошибку. Если `initialize` не указана, `set` не вызывается, а базовое хранилище записывается напрямую. Таким образом, `set` может рассчитывать на уже существующее поле, и ему не нужно отдельно отслеживать это.
- Init method - Метод инициализации: объект со свойствами :
  - `method` : Функция для замены метода
  - `initialize` : функция без аргументов, возвращаемое значение которой игнорируется, которая вызывается с вновь созданным объектом в качестве получателя.

### 3. Применение декораторов.
Декораторы применяются после вызова всех декораторов. Промежуточные этапы алгоритма применения декоратора не наблюдаемы -- вновь созданный класс не становится доступным до тех пор, пока не будут применены все декораторы методов и нестатических полей.

Декоратор класса вызывается только после вызова и применения всех декораторов методов и полей.

Наконец, статические поля выполняются и применяются.

#### Глубокая семантика полей декораторов.
Поля декораторов имеют семантику пар геттер-сеттер, поддерживаемую частным полем (private field). То есть,

```js
function id(v) { return v; }

class C {
  @id x = y;
}
```
имеет семантику
```js
class C {
  #x = y;
  get x() { return this.#x; }
  set x(v) { this.#x = v; }
}
```
Эта семантика подразумевает, что оформленные поля имеют «TDZ», как частные поля (private fields). Например, следующее - это TypeError, потому что y обращаются до того, как он добавлен в экземпляр.
```js
class C {
  @id x = this.y;
  @id y;
}
new C;  // TypeError
```
Пара геттер / сеттер - это обычные объекты метода JS, не перечисляемые, как и другие методы. Базовые частные поля (private fields) добавляются одно за другим, перемежаясь с инициализаторами, как обычные частные поля (private fields).

#### Цели дизайна.
* Как использовать декораторы, так и писать свои собственные декораторы должно быть легко. 
* Декораторы должны влиять на то, что они декорируют, и избегать сбивающих с толку / нелокальных эффектов.

##### Анализ вариантов использования

Мы обнаружили некоторые важные варианты использования:
* Хранение метаданных о классах, полях и методах 
* Превращение поля в `accessor` 
* Обертывание (Wrapping) метода

##### Ограничения транспилятора и нативной реализации
Из транспилеров:
1. Вывод транспилятора не должен быть слишком большим (как с точки зрения прямого вывода перевода, так и размера библиотеки поддержки).
2. Должна быть предусмотрена возможность транспиляции для каждого файла без межфайловой информации.

Из собственных реализаций: A: «Форма» класса должна быть очевидной синтаксически, без выполнения кода B: Обработка декораторов не должна быть слишком сложной, так как это соответствует сложной реализации C: минимизировать или исключить наблюдаемые мутации объектов, пока создание класса.

Ограничения 2 + A вместе означают, что все изменения формы должны быть синтаксически очевидными. Это ограничение достигается за счет того, что все изменения формы синтаксически становятся родительскими там, где определен класс, путем явного выбора либо «аннотации» вместо значения по умолчанию (или, в предыдущем предложении с противоположным значением по умолчанию, «ловушки»).

##### Вне области видимости `scope`.
Некоторые вещи, которые были описаны как потенциальные декораторы, не вписывались бы в схему здесь и потребовали бы либо специального синтаксиса для удовлетворения ограничений, установленных делегатами TC39, либо использования существующих идиом, чтобы обойти необходимость в декораторе.
* `set` : Этот декоратор изменит поле с семантики [[Define]] на [[Set]]. Этот декоратор изменяет тип кода, выполняемый в конструкторе, по-другому, что не видно из синтаксиса. Доступ к этой семантике можно получить, поместив строку кода в конструктор, а не объявление поля. Однако обратите внимание, что это предложение снижает необходимость выбора семантики [[Set]] несколькими способами:
  * Семантика [[Set]] определяла, как поля работают с устаревшими / экспериментальными декораторами, которые создают средства доступа. В этом предложении эти механизмы заменены декорированными объявлениями полей, которые инициализируют базовое хранилище, а не затеняют средство доступа.
  * Если сеттер унаследован, можно написать декоратор для поля, которое конкретно вызывает супер геттеры и сеттеры, вместо использования базового хранилища.
* `@frozen` : этот декоратор замораживает весь класс, включая статические поля. Такое изменение невозможно в фазовом порядке декораторов, где декораторы классов выполняются до выполнения статических полей. Вместо этого класс может быть заморожен в одной строке после класса или возможного будущего синтаксиса для замораживания класса.
* `@enumerable` : этот декоратор сделает метод перечисляемым, переопределив его значение по умолчанию неперечислимым. Декораторы не могут изменять атрибуты свойств, поскольку они не получают дескрипторы свойств для управления ими, как в декораторах этапа 1, и не передаются конструктору класса, чтобы сделать это императивно. Это сделано для удовлетворения требований реализаций, согласно которым декораторы оставляют классы со статически предсказуемыми формами. Вместо этого подобные изменения могут быть выполнены с помощью вызовов `Object.defineProperty` после выполнения определения класса.
* `@reader` : этот декоратор для частного поля создаст открытый метод доступа для его чтения. Создать невозможно, так как декораторам не предоставляется доступ к классу. Такое изменение формы противоречило бы целям «статической формы», поставленным разработчиками собственного кода.

##### План стандартизации.
* Представлен  в сентябре 2020 года или когда будет готов.
* Обдумайте открытые вопросы в рамках предложения, представив их TC39 и обсудив далее в телефонных звонках, проводимых каждые две недели, чтобы представить заключение комитету на следующем собрании:
  * Что должно быть в рамках «MVP»? (Например, следует ли добавлять декораторы параметров в первый раз или в последующее предложение?)
  * Какими должны быть детали объектной модели аннотации? (Это определенно требует повторения.)
  * Как следует обрабатывать варианты использования методов инициализации `init` - контекстное ключевое слово, миксины + аннотации или какая-то другая модель? Насколько важны эти варианты использования для MVP?

* Если обратная связь положительная, напишите текст спецификации и внедрите в транспайлеры
* Сделать предложение для этапа 3 не раньше, чем через шесть месяцев после начала прототипирования, чтобы у нас было время собрать опыт разработчиков в транспиляторах.

## FAQ
### Как мне сегодня использовать декораторы в транспиляторах?
К сожалению, мы попали в классическую ловушку: «Старое устарело, а новое еще не готово!» А пока лучше продолжать использовать старую вещь.

Группа сторонников декораторов порекомендовала бы продолжать использовать "устаревшие" декораторы Babel или "экспериментальные" декораторы TypeScript. Если вы используете декораторы сегодня, вероятно, вы уже используете одну из этих версий. Обратите внимание, что эти декораторы зависят от "[[Set]] семантики" для объявлений полей (в Babel, свободный режим). Мы рекомендуем, чтобы эти инструменты поддерживали семантику [[Set]] вместе с унаследованными декораторами, пока не станет возможным переход к декораторам этого предложения.

Babel 7 поддерживает предложение декораторов, представленное TC39 на собрании TC39 в ноябре 2018 года. Их можно использовать в экспериментальных целях, но они сталкиваются со значительными проблемами производительности и пока не получили широкого распространения; мы не планируем продолжать продвигать это предложение в TC39. Поэтому мы не рекомендуем использовать эту версию для серьезной работы. В последующих предложениях по добавлению дополнительных встроенных декораторов мы надеемся, что сможем восстановить дополнительную функциональность, которую поддерживало предложение декораторов от ноября 2018 года.

### Как это предложение соотносится с другими версиями декораторов?
#### Сравнение с "устаревшими" декораторами Babel.
Декораторы устаревшего режима Babel основаны на состоянии предложения декораторов JavaScript по состоянию на 2014 год. В дополнение к изменениям синтаксиса, перечисленным выше, соглашение о вызовах устаревших декораторов Babel отличается от этого предложения:

* Legacy decorators (Устаревшие декораторы)  вызываются с «целью» (создаваемый класс или прототип), тогда как в этом предложении создаваемый класс не предоставляется декораторам.
* Legacy decorators (Устаревшие декораторы)  вызываются с полным дескриптором свойства, тогда как это предложение вызывает декораторы только с «украшаемой вещью» и объектом контекста. Это означает, например, что невозможно изменить атрибуты свойства, и что геттеры и сеттеры не «объединяются», а скорее оформляются отдельно.

Несмотря на эти различия, в целом с помощью этого предложения декораторов должно быть возможно достичь той же функциональности, что и унаследованные декораторы Babel. Если вы видите, что в этом предложении отсутствуют важные функции, сообщите о проблеме.

#### Сравнение с «экспериментальными» декораторами TypeScript.
Экспериментальные декораторы TypeScript во многом похожи на устаревшие декораторы Babel, поэтому комментарии в этом разделе также применимы. К тому же:
* Это предложение не включает декораторы параметров, но они могут быть предоставлены будущими встроенными декораторами, см. [EXTENSIONS.md](https://github.com/tc39/proposal-decorators/blob/simplified/EXTENSIONS.md).
* Декораторы TypeScript запускают все декораторы экземпляров перед всеми статическими декораторами, тогда как порядок оценки в этом предложении основан на порядке в программе, независимо от того, являются ли они статическими или экземплярами.

Несмотря на эти различия, в целом с помощью этого предложения декораторов должно быть возможно достичь той же функциональности, что и с экспериментальными декораторами TypeScript. Если вы видите, что в этом предложении отсутствуют важные функции, сообщите о проблеме.

#### Сравнение с предыдущим предложением декораторов Этапа 2.
Предыдущее предложение декораторов для этапа 2 было более полнофункциональным, чем это предложение, в том числе:
* Возможность всех декораторов добавлять произвольные «лишние» элементы класса, а не просто обертывать / изменять декорируемый элемент.
* Возможность объявлять новые частные поля (private fields), включая повторное использование private name в нескольких классах.
* Доступ декоратора класса (Class decorator) для управления всеми полями и методами внутри класса.
* Более гибкая обработка инициализатора, обработка его как преобразователя.

Предыдущее предложение декораторов этапа 2 было основано на концепции дескрипторов, которые заменяют различные элементы класса. Таких дескрипторов в этом предложении нет. Однако эти дескрипторы придавали форме класса слишком большую гибкость / динамизм, чтобы ее можно было эффективно оптимизировать.

В этом предложении декораторов эти особенности намеренно опущены, чтобы значение декораторов оставалось «хорошо ограниченным» и интуитивно понятным, а также для упрощения реализации как в транспиляторах, так и в собственных движках.

#### Сравнение с предложением "статических декораторов".
Идея статических декораторов заключалась в том, чтобы включить набор встроенных декораторов и поддерживать определяемые пользователем декораторы, производные от них. Статические декораторы находились в отдельном пространстве имен, чтобы поддерживать возможность статического анализа.

Предложение статических декораторов страдало как из-за чрезмерной сложности, так и из-за недостаточной оптимизируемости. Это предложение позволяет избежать этой сложности, возвращаясь к общей модели декораторов, являющихся обычными функциями.

См. [V8's analysis of decorator optimizability](https://docs.google.com/document/d/1GMp938qlmJlGkBZp6AerL-ewL1MWUDU8QzHBiNvs3MM/edit) для получения дополнительной информации об отсутствии оптимизируемости предложения статических декораторов, на которую это предложение направлено.

### Если предыдущие предложения декораторов TC39 не сработали, почему бы не вернуться и стандартизировать устаревшие декораторы TS / Babel?
**Оптимизируемость**: это предложение декоратора и унаследованные декораторы являются общими для декораторов, являющихся функциями. Тем не менее, соглашение о вызовах этого предложения разработано так, чтобы его можно было лучше оптимизировать движками за счет внесения следующих изменений в устаревшие декораторы:
* Строящийся неполный класс не предоставляется декораторам, поэтому он не должен подвергаться наблюдаемым изменениям формы во время оценки определения класса.
* Только декорируемая конструкция может быть изменена по своему содержанию; «форма» дескриптора свойства не может измениться.

**Несовместимость с семантикой поля [[Define]]** : унаследованные декораторы, когда они применяются к объявлениям полей, сильно зависят от семантики, которую инициализаторы поля вызывают установщиками. TC39 [пришел к выводу](https://github.com/tc39/proposal-class-fields/blob/master/README.md#public-fields-created-with-objectdefineproperty), что вместо этого объявления полей действуют как `Object.defineProperty`. Это решение приводит к тому, что многие шаблоны с устаревшими декораторами больше не работают. Хотя Babel предоставляет способ справиться с этим, сделав инициализатор доступным как преобразователь, разработчики отклонили эту семантику как добавление затрат времени выполнения.

### Зачем отдавать предпочтение функциям «устаревших» декораторов, таких как классы, по сравнению с другими функциями, которые декораторы могут предоставить?